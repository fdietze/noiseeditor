<?xml version='1.0' encoding='UTF-8'?>
<document>
			<module name="GameEngine"></module>
			<nodes><node type="preview" title="Preview" id="1">
						<location x="625" y="16"></location>
						<size width="388" height="383"></size><image offsety="-1.8515549649576541" offsetx="-5.841987328514233" zoom="0.028966437973668775"></image><view mode="values" perspective="sideview_zup"></view><depthslider value="50.0"></depthslider><grid selected="false"></grid><continous selected="false"></continous>
						<arguments><language name="scala"><argument name="d" datatype="Double"></argument><argument name="m" datatype="Material"></argument></language></arguments>

						<sliders>
							
						</sliders>
		
						<functions><language name="scala"><function name="result_uid4eb7fb6f" returntype="(Double, Material)" outname="result">(d,m)</function></language></functions>
					</node><node type="custom" title="Custom" id="2">
						<location x="200" y="23"></location>
						<size width="417" height="633"></size>
						<arguments><language name="scala"><argument name="v" datatype="Vec3"></argument><argument name="a" datatype="Double"></argument><argument name="b" datatype="Double"></argument><argument name="c" datatype="Double"></argument></language></arguments>

						<sliders>
							<slider name="lin1" formula="s" value="50"></slider><slider name="lin2" formula="s" value="50"></slider><slider name="exp1" formula="pow(256,((s-0.5)*2))" value="50"></slider><slider name="exp2" formula="pow(256,((s-0.5)*2))" value="50"></slider>
						</sliders>
		
						<functions><language name="scala"><function name="custom_f2_uid4eb7fb6f" returntype="Double" outname="o">try{{	val pointspercube = Array(
		4, 3, 1, 1, 1, 2, 4, 2, 2, 2, 5, 1, 0, 2, 1, 2, 2, 0, 4, 3, 2, 1, 2, 
		1, 3, 2, 2, 4, 2, 2, 5, 1, 2, 3, 2, 2, 2, 2, 2, 3, 2, 4, 2, 5, 3, 2, 
		2, 2, 5, 3, 3, 5, 2, 1, 3, 3, 4, 4, 2, 3, 0, 4, 2, 2, 2, 1, 3, 2, 2, 
		2, 3, 3, 3, 1, 2, 0, 2, 1, 1, 2, 2, 2, 2, 5, 3, 2, 3, 2, 3, 2, 2, 1, 
		0, 2, 1, 1, 2, 1, 2, 2, 1, 3, 4, 2, 2, 2, 5, 4, 2, 4, 2, 2, 5, 4, 3, 
		2, 2, 5, 4, 3, 3, 3, 5, 2, 2, 2, 2, 2, 3, 1, 1, 5, 2, 1, 3, 3, 4, 3, 
		2, 4, 3, 3, 3, 4, 5, 1, 4, 2, 4, 3, 1, 2, 3, 5, 3, 2, 1, 3, 1, 3, 3, 
		3, 2, 3, 1, 5, 5, 4, 2, 2, 4, 1, 3, 4, 1, 5, 3, 3, 5, 3, 4, 3, 2, 2, 
		1, 1, 1, 1, 1, 2, 4, 5, 4, 5, 4, 2, 1, 5, 1, 1, 2, 3, 3, 3, 2, 5, 2, 
		3, 3, 2, 0, 2, 1, 1, 4, 2, 1, 3, 2, 1, 2, 2, 3, 2, 5, 5, 3, 4, 5, 5, 
		2, 4, 4, 5, 3, 2, 2, 2, 1, 4, 2, 3, 3, 4, 2, 5, 4, 2, 4, 2, 2, 2, 4, 
		5, 3, 2 )

	val maxorder = 4
	//TODO: val densityadjustment = 0.398150

	def worley(x:Double,y:Double,z:Double):Double = {
		def intfloor(x:Double) = x.floor.toInt
		def coordhash(X:Int,Y:Int,Z:Int) = (702395077*X + 915488749*Y + 2120969693*Z) &amp; 0x7FFFFFFF
		def nextrandom(last:Int) = (1402024253*last + 586950981) &amp; 0x7FFFFFFF
		//def hash(k:Int) = mod(((k*34)+1)*k, 289).toInt
		//def coordhash(X:Int,Y:Int,Z:Int) = hash(hash(hash(X)+Y)+Z)
		//def nextrandom(last:Int) = (1103515245 * last + 12345) &amp; 0x7FFFFFFF
		def distance(x0:Double,y0:Double,z0:Double,x1:Double,y1:Double,z1:Double) = (x0-x1)*(x0-x1) + (y0-y1)*(y0-y1) + (z0-z1)*(z0-z1)
		def randomfloat(rand:Int) = rand / 2147483647.0
	
		val X = intfloor(x)
		val Y = intfloor(y)
		val Z = intfloor(z)

		val relx = x - X
		val rely = y - Y
		val relz = z - Z
		
		//import scala.Double.MaxValue
		//val distances = Array.ofDim(maxorder), fill with maxvalue
		var mindistance = scala.Double.MaxValue
		
		// cube face distances
		val dstx = relx*relx
		val dsty = rely*rely
		val dstz = relz*relz
		val dstmx = (1.0-relx)*(1.0-relx)
		val dstmy = (1.0-rely)*(1.0-rely)
		val dstmz = (1.0-relz)*(1.0-relz)
		
		testcube(0,0,0)
		
		// test 6 facing neighbours
		if(  dstx &lt; mindistance ) testcube(-1, 0, 0)
		if(  dsty &lt; mindistance ) testcube( 0,-1, 0)
		if(  dstz &lt; mindistance ) testcube( 0, 0,-1)
		if( dstmx &lt; mindistance ) testcube( 1, 0, 0)
		if( dstmy &lt; mindistance ) testcube( 0, 1, 0)
		if( dstmz &lt; mindistance ) testcube( 0, 0, 1)
		
		// test 12 edge cubes
		if( dstx +  dsty &lt; mindistance) testcube(-1,-1, 0)
		if( dstx +  dstz &lt; mindistance) testcube(-1, 0,-1)
		if( dsty +  dstz &lt; mindistance) testcube( 0,-1,-1)
		if(dstmx + dstmy &lt; mindistance) testcube( 1, 1, 0)
		if(dstmx + dstmz &lt; mindistance) testcube( 1, 0, 1)
		if(dstmy + dstmz &lt; mindistance) testcube( 0, 1, 1)
		if( dstx + dstmy &lt; mindistance) testcube(-1, 1, 0)
		if( dstx + dstmz &lt; mindistance) testcube(-1, 0, 1)
		if( dsty + dstmz &lt; mindistance) testcube( 0,-1, 1)
		if(dstmx +  dsty &lt; mindistance) testcube( 1,-1, 0)
		if(dstmx +  dstz &lt; mindistance) testcube( 1, 0,-1)
		if(dstmy +  dstz &lt; mindistance) testcube( 0, 1,-1)
		
		// test 8 corner cubes
		if( dstx +  dsty +  dstz &lt; mindistance) testcube(-1,-1,-1)
		if( dstx +  dsty + dstmz &lt; mindistance) testcube(-1,-1, 1)
		if( dstx + dstmy +  dstz &lt; mindistance) testcube(-1, 1,-1)
		if( dstx + dstmy + dstmz &lt; mindistance) testcube(-1, 1, 1)
		if(dstmx +  dsty +  dstz &lt; mindistance) testcube( 1,-1,-1)
		if(dstmx +  dsty + dstmz &lt; mindistance) testcube( 1,-1, 1)
		if(dstmx + dstmy +  dstz &lt; mindistance) testcube( 1, 1,-1)
		if(dstmx + dstmy + dstmz &lt; mindistance) testcube( 1, 1, 1)



		def testcube(dx:Int, dy:Int, dz:Int) {
			val cubex = X + dx
			val cubey = Y + dy
			val cubez = Z + dz
	 		
			var rng = coordhash(cubex,cubey,cubez)
			var p = 0
			val pointcount = pointspercube(rng &amp; 0xFF)
			while( p &lt; pointcount ) {
				rng = nextrandom(rng)
				val pointx = cubex + randomfloat(rng)
				rng = nextrandom(rng)
				val pointy = cubey + randomfloat(rng)
				rng = nextrandom(rng)
				val pointz = cubez + randomfloat(rng)

				mindistance = math.min(mindistance, distance(x, y, z, pointx, pointy, pointz))
				p += 1
			}
		}

		return mindistance
	}

worley(a,b,c)}.toDouble}catch{ case _ â‡’ 0.0}</function></language></functions>
					</node><node type="predefined" title="World coordinates" id="3">
						<location x="13" y="20"></location>
						
						<arguments><language name="scala"></language><language name="glsl"></language><language name="prediction"></language></arguments>

						<sliders>
							<slider name="scale" formula="pow(256, 1-s*2)" value="50"></slider>
						</sliders>
		
						<functions><language name="scala"><function name="scalesrcv_uid4eb7fb6f" returntype="Vec3" outname="v">world   * scale</function><function name="scalesrcx_uid4eb7fb6f" returntype="Double" outname="x">world.x * scale</function><function name="scalesrcy_uid4eb7fb6f" returntype="Double" outname="y">world.y * scale</function><function name="scalesrcz_uid4eb7fb6f" returntype="Double" outname="z">world.z * scale</function></language><language name="glsl"><function name="scalesrcv_uid4eb7fb6f" returntype="vec3" outname="v">return world.xyz * scale;</function><function name="scalesrcx_uid4eb7fb6f" returntype="float" outname="x">return world.x * scale;</function><function name="scalesrcy_uid4eb7fb6f" returntype="float" outname="y">return world.y * scale;</function><function name="scalesrcz_uid4eb7fb6f" returntype="float" outname="z">return world.z * scale;</function></language><language name="prediction"><function name="scalesrcv_uid4eb7fb6f" returntype="Volume" outname="v">world   * scale</function><function name="scalesrcx_uid4eb7fb6f" returntype="Interval" outname="x">world.x * scale</function><function name="scalesrcy_uid4eb7fb6f" returntype="Interval" outname="y">world.y * scale</function><function name="scalesrcz_uid4eb7fb6f" returntype="Interval" outname="z">world.z * scale</function></language></functions>
					</node></nodes>
			<connections><connection>
						<in nodeid="2" connector="2"></in>
						<out nodeid="3" connector="2"></out>
					</connection><connection>
						<in nodeid="2" connector="1"></in>
						<out nodeid="3" connector="1"></out>
					</connection><connection>
						<in nodeid="2" connector="3"></in>
						<out nodeid="3" connector="3"></out>
					</connection><connection>
						<in nodeid="1" connector="0"></in>
						<out nodeid="2" connector="0"></out>
					</connection></connections>
		</document>